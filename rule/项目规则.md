这是一个(后端采用:Spring Boot+MyBatis（Java方案）
前端使用:Vue3+Element Plus框架，通过脚手架初始化项目）web项目

# my-back
back.zip springboot框架项目压缩包
后端项目保存在文件夹back下
数据库初始化文件保存在文件夹back/init_database下

## 数据库mysql连接配置
- host: dbprovider.ap-southeast-1.clawcloudrun.com
- port: 35964
- user: root
- password: j75fljbf

# my-code   

## 一、代码注释规则

1. **文件头部注释**
   每个源代码文件开头，注明文件功能、作者、创建 / 修改时间、版本信息等，例如：

```python
# 文件名：user_management.py
# 功能：用户管理模块，包含用户注册、登录、信息修改等功能
# 作者：张三
# 创建时间：2025-08-09
# 版本：v1.0.0
# 备注：依赖于数据库模块 db_connection.py
```

2. **函数 / 类注释**
   每个函数或类需说明其用途、参数、返回值、异常情况（若有），可使用文档字符串（docstring），例如：

```java
/**
 * 用户登录验证函数
 * @param username 用户名（字符串，非空）
 * @param password 密码（字符串，长度≥6）
 * @return boolean 登录成功返回true，失败返回false
 * @throws IllegalArgumentException 当用户名或密码格式不合法时抛出
 */
public boolean userLogin(String username, String password) {
    // 函数逻辑...
}
```

3. **关键逻辑注释**
   对复杂逻辑、算法步骤、特殊处理（如边界条件、临时解决方案）添加注释，避免 “自注释代码” 的误区（即认为代码本身清晰无需注释），例如：

```javascript
// 计算用户积分：基础分（100）+ 等级系数（等级×10）+ 额外奖励（最多50）
// 注意：新用户（等级0）额外奖励固定为20
function calculateScore(level, isNewUser) {
    let base = 100;
    let levelBonus = level * 10;
    let extra = isNewUser ? 20 : Math.min(50, level * 5); // 老用户额外奖励与等级挂钩，上限50
    return base + levelBonus + extra;
}
```

4. **注释风格统一**

- 单行注释用 `//`（C/C++/Java/JS）或 `#`（Python/Shell），多行注释用 `/* */` 或文档字符串，避免混合使用；

- 注释与代码保持缩进一致，例如：

  ```python
  if age < 18:
      # 未成年人限制：仅允许查看基础内容
      show_basic_content()
  else:
      # 成年人：解锁全部内容
      show_full_content()
  ```

## 二、代码结构与逻辑规则

1. **模块化拆分**
   将功能拆分为独立模块 / 函数，单个函数 / 类专注于单一职责（遵循 “单一职责原则”），例如：
   - 不写 “万能函数”（一个函数同时处理登录、注册、数据统计）；
   - 工具类（如日期处理、加密解密）单独封装，避免重复代码。

2. **命名规范**

- 变量 / 函数 / 类名使用有意义的名称，避免拼音、缩写（通用缩写如id、url除外），例如：
  - 不好：`a`、`temp`、`func1`、`shujv`
  - 好：`userId`、`userList`、`calculateTotalPrice()`、`dataManager`
  - 遵循语言约定：如 Java 类名大写开头（`UserService`）、Python 常量全大写（`MAX_RETRY`）。

3. **逻辑清晰化**

- 避免嵌套过深（建议不超过 3 层），可拆分中间变量或子函数，例如：

```bad
// 嵌套过深，难以阅读
if (user != null) {
    if (user.isActive()) {
        if (user.getRole() == "admin") {
            // 管理员操作...
        }
    }
}
```

```good
// 拆分条件，逻辑更清晰
if (user == null || !user.isActive()) {
    return; // 非活跃用户直接返回
}
if (user.getRole() == "admin") {
    // 管理员操作...
}
```

- 使用 “正向判断” 代替 “负向判断”，例如用 `if (isValid)` 而非 `if (!isNotValid)`。

4. **处理边界条件**
   明确处理空值、异常输入、数组越界等情况，避免程序崩溃，例如：

```python
def get_user_name(user_list, index):
    # 处理索引越界和空列表
    if not user_list or index < 0 or index >= len(user_list):
        return "未知用户"  # 友好返回默认值
    return user_list[index].name
```

## 三、代码格式与可读性规则

1. **缩进与换行**

- 使用统一缩进（4 个空格或 1 个 Tab，避免混合）；
- 运算符前后、逗号后加空格，例如：`a = (b + c) * 2` 而非 `a=(b+c)*2`；
- 长代码换行（如超过 80-120 字符），在逗号或运算符后换行，例如：

```c
int result = calculateSum(dataArray, 0, 100) 
          + calculateAverage(scoreList, 5, 20) 
          - 10; // 换行后对齐，逻辑清晰
```

2. **空行分隔**
   用空行分隔不同逻辑块（如函数之间、循环前后），例如：

   ```javascript
   // 初始化数据
   let users = [];
   let total = 0;
   
   // 读取用户数据
   function loadUsers() {
       // ...
   }
   
   // 计算总人数
   function countTotal() {
       // ...
   }
   ```

3. **避免冗余代码**

- 重复出现 3 次以上的代码块，封装为函数或变量；
- 移除未使用的变量、注释掉的代码（如需保留历史代码，用版本控制工具如 Git 管理）。

## 四、示例：符合规则的代码片段（Python）

```python
# 文件名：order_processing.py
# 功能：订单处理工具，计算订单金额、生成订单号
# 作者：李四
# 创建时间：2025-08-09
# 版本：v1.0.0

import datetime
import random

def generate_order_id(user_id):
    """
    生成唯一订单号
    规则：用户ID（前6位，不足补0）+ 时间戳（年月日时分）+ 随机数（3位）
    @param user_id: 用户ID（整数）
    @return: 字符串类型的订单号，例如"001234202508091530123"
    """
    # 处理用户ID：确保6位，不足前补0
    user_str = f"{user_id:06d}"  # 例如：123 → "000123"
    
    # 获取当前时间戳（年月日时分）
    time_str = datetime.datetime.now().strftime("%Y%m%d%H%M")
    
    # 生成3位随机数（000-999）
    random_str = f"{random.randint(0, 999):03d}"
    
    return user_str + time_str + random_str


def calculate_order_amount(goods_list, discount=0):
    """
    计算订单总金额
    @param goods_list: 商品列表，每个元素为字典{"price": 单价, "quantity": 数量}
    @param discount: 折扣（0-1之间的小数，默认0不打折）
    @return: 浮点型总金额（保留2位小数）
    @throws ValueError: 当折扣不在0-1范围或商品列表为空时抛出
    """
    # 校验输入合法性
    if not goods_list:
        raise ValueError("商品列表不能为空")
    if not (0 <= discount <= 1):
        raise ValueError("折扣必须在0到1之间")
    
    # 计算商品总价（单价×数量之和）
    total = 0.0
    for goods in goods_list:
        # 确保商品有单价和数量字段，且为正数
        price = goods.get("price", 0)
        quantity = goods.get("quantity", 0)
        if price < 0 or quantity < 0:
            raise ValueError(f"商品数据错误：单价{price}或数量{quantity}不能为负数")
        total += price * quantity
    
    # 应用折扣并保留2位小数
    final_amount = total * (1 - discount)
    return round(final_amount, 2)
```


#

# my-front

前端项目保存在文件夹front下

# my-markdan
所有.md文件都保存在 markdown文件夹中,README.md 文档除外。
# my-test
测试文件保存在文件夹test文件夹下

# API 合约文档
api接口设计文档保存在maekdan文件夹下
## 一、API 合约概述

### 1.1 合约目标

定义前后端交互的标准接口规范，明确接口设计、参数格式、响应逻辑等核心要素，确保前后端开发的一致性、可测试性及协作效率。

### 1.2 合约原则

- **接口优先**：API 设计先行于代码实现，所有开发基于已确认的接口合约开展
- **版本管理**：支持 API 版本迭代，版本变更需同步更新合约并通知相关方
- **标准化**：统一请求 / 响应格式、数据类型、状态码等基础规范
- **可测试**：每个接口需包含明确的测试用例（输入、预期输出），支持独立验证
- **可追溯**：合约变更需记录版本号、修改内容、责任人及时间，便于回溯

## 二、通用规范

### 2.1 基础信息

| 项目             | 内容                           | 说明                                                         |
| ---------------- | ------------------------------ | ------------------------------------------------------------ |
| **Base URL**     | `http://localhost:8080/api/v1` | 接口基础路径，版本号（v1）需随重大变更升级                   |
| **Content-Type** | `application/json`             | 统一采用 JSON 格式传输数据                                   |
| **字符编码**     | `UTF-8`                        | 确保多语言字符兼容                                           |
| **时间格式**     | `ISO 8601`                     | 示例：`2025-01-09T10:30:00Z`（UTC 时间）、`2025-01-09T18:30:00+08:00`（带时区） |
| **请求方法**     | 遵循 RESTful 规范              | GET（查询）、POST（创建）、PUT（全量更新）、PATCH（部分更新）、DELETE（删除） |

### 2.2 统一响应格式



```typescript
interface ApiResponse<T> {
  code: number;           // 业务状态码（非HTTP状态码，与下表对应）
  message: string;        // 响应描述信息（成功/失败原因）
  data: T | null;         // 响应数据（成功时为业务数据，失败时可为null或错误详情）
  timestamp: string;      // 服务器响应时间戳（ISO 8601格式）
}
```

### 2.3 状态码定义

| 状态码 | 含义       | 适用场景                     | 前端处理建议                                |
| ------ | ---------- | ---------------------------- | ------------------------------------------- |
| 200    | 成功       | 请求处理完成且结果正常       | 解析 data 展示业务数据                      |
| 201    | 创建成功   | 资源（如用户、订单）创建完成 | 可跳转至详情页或提示创建结果                |
| 400    | 请求错误   | 参数格式错误、缺失必填项等   | 展示具体参数错误信息（如`data.errors`）     |
| 401    | 未授权     | 未登录、token 过期或无效     | 跳转至登录页                                |
| 403    | 禁止访问   | 登录状态下无操作权限         | 提示 "无权限"，可跳转至首页                 |
| 404    | 资源不存在 | 请求的 URL 或资源 ID 不存在  | 提示 "资源不存在"                           |
| 409    | 资源冲突   | 资源已存在（如用户名重复）   | 提示冲突原因（如 "用户名已被注册"）         |
| 423    | 账户锁定   | 账户因安全原因被临时锁定     | 提示锁定原因及解锁方式                      |
| 500    | 服务器错误 | 后端逻辑异常、数据库错误等   | 提示 "系统繁忙，请稍后重试"，不展示技术细节 |

## 三、API 接口设计示例

### 3.1 用户注册接口

#### 基本信息

- **接口标识**：`AUTH_REGISTER`（全局唯一，用于文档索引和开发沟通）
- **请求路径**：`POST /auth/register`（完整路径：Base URL + 此路径）
- **接口描述**：新用户通过用户名、邮箱和密码创建账户
- **认证要求**：无需认证（公开接口）
- **适用业务单元**：用户注册流程（独立业务单元，需同步开发前端注册页面）

#### 请求参数

```typescript
interface RegisterRequest {
  username: string;        // 用户名，3-20字符，仅含字母、数字、下划线
  email: string;           // 邮箱地址，需符合标准格式（如xxx@xx.com）
  password: string;        // 密码，8-32字符，必须包含大小写字母和数字
  confirmPassword: string; // 确认密码，需与password完全一致
}
```

#### 参数验证规则

```json
{
  "username": {
    "required": true,
    "type": "string",
    "minLength": 3,
    "maxLength": 20,
    "pattern": "^[a-zA-Z0-9_]+$",
    "message": "用户名只能包含字母、数字、下划线，长度3-20字符"
  },
  "email": {
    "required": true,
    "type": "email",
    "message": "请输入有效的邮箱地址（如xxx@xx.com）"
  },
  "password": {
    "required": true,
    "type": "string",
    "minLength": 8,
    "maxLength": 32,
    "pattern": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)", // 至少1个小写、1个大写、1个数字
    "message": "密码必须包含大小写字母和数字，长度8-32字符"
  },
  "confirmPassword": {
    "required": true,
    "type": "string",
    "custom": "mustMatchPassword", // 自定义验证：与password字段值一致
    "message": "确认密码必须与密码一致"
  }
}
```

#### 响应示例

##### 成功响应（状态码 201）

```typescript
interface RegisterSuccessResponse {
  code: 201;
  message: "注册成功，已发送验证邮件";
  data: {
    userId: number;        // 系统生成的唯一用户ID
    username: string;      // 注册时提交的用户名
    email: string;         // 注册时提交的邮箱（用于后续登录）
    createdAt: string;     // 账户创建时间（ISO 8601格式）
  };
  timestamp: string;
}
```

##### 失败响应

- **用户名已存在（409）**

  

  ```json
  {
    "code": 409,
    "message": "用户名已被注册，请更换",
    "data": null,
    "timestamp": "2025-01-09T10:30:00Z"
  }
  ```

- **参数验证失败（400）**

  ```json
  {
    "code": 400,
    "message": "参数验证失败，请检查输入",
    "data": {
      "errors": [
        {
          "field": "username",
          "message": "用户名只能包含字母、数字、下划线"
        },
        {
          "field": "password",
          "message": "密码必须包含大小写字母和数字"
        }
      ]
    },
    "timestamp": "2025-01-09T10:31:00Z"
  }
  ```

#### 调试说明

- **测试用例 1（成功场景）**：
  - 请求体：`{"username":"test_user1","email":"test@example.com","password":"Test1234","confirmPassword":"Test1234"}`
  - 预期响应：code=201，data 包含 userId 等信息
- **测试用例 2（失败场景 - 用户名重复）**：
  - 请求体：`{"username":"existing_user","email":"new@example.com","password":"Test1234","confirmPassword":"Test1234"}`
  - 预期响应：code=409，message="用户名已被注册"
- **跨域配置**：后端需允许前端域名的跨域请求（Access-Control-Allow-Origin）

# AI自动化开发前后端并行协同规则 (V1.1)

**核心原则：**

1.  **API驱动开发 (API-Driven Development)**
2.  **小步迭代，快速集成 (Small Iterations, Fast Integration)**
3.  **功能闭环交付 (Closed-Loop Feature Delivery)**
4.  **测试驱动质量 (Test-Driven Quality):** 每个环节的产出都必须有相应的自动化测试来保证其质量。

---

### **开发工作流（必须严格遵守）**

**第一步：任务分解与API合约定义 (Task Decomposition & API Contract Definition)**

*   **行动：** 分析功能需求，首先定义后端API的“合约”。
*   **产出物（必须优先生成）：**
    *   **路径 (Path):** 例如 `/api/v1/users/register`
    *   **方法 (Method):** 例如 `POST`
    *   **请求体 (Request Body):** 定义需要前端提交的数据结构、字段名、类型和校验规则（如 `username`, `password`, `email`）。
    *   **成功响应 (Success Response):** 定义HTTP状态码（如 `201`）和返回的数据结构。
    *   **失败响应 (Error Response):** 定义各种错误情况下的状态码（如 `400`, `409`）和返回的错误信息结构。
*   **AI汇报示例：** “已为‘用户注册’功能定义API合约，路径为POST /api/v1/users/register。下一步将实现后端逻辑。”

**第二步：后端API实现与单元/集成测试 (Backend API Implementation & Unit/Integration Testing)**

*   **行动：**
    1.  基于API合约，编写后端的业务逻辑。
    2.  **【测试要求】**：为实现的业务逻辑编写**单元测试**和**集成测试**。
*   **产出物：**
    1.  可运行的API端点代码。
    2.  覆盖主要业务逻辑和边界情况的**单元测试**和**集成测试**代码。
*   **AI汇报示例：** “后端API‘用户注册’已实现，并通过了单元与集成测试。下一步将开发前端UI。”

**第三步：前端UI开发与组件测试 (Frontend UI Development & Component Testing)**

*   **行动：**
    1.  基于功能需求，创建UI组件。
    2.  **【测试要求】**：为UI组件编写**组件测试**，验证其在不同props下的渲染、展现和基本交互是否正确。
*   **产出物：**
    1.  UI组件、页面布局和样式。
    2.  针对UI组件的**组件测试**代码（例如，使用 Jest/Vitest + Testing Library）。
*   **AI汇报示例：** “前端‘注册页面’UI组件已创建，并通过了组件测试。下一步将进行API对接。”

**第四步：前端API对接与状态管理 (Frontend API Integration & State Management)**

*   **行动：** 在前端代码中，编写调用第二步实现的API的逻辑。
*   **产出物：**
    1.  发起网络请求的代码（如使用axios, fetch）。
    2.  完整的客户端状态管理逻辑，必须覆盖：加载中 (Loading), 成功 (Success), 失败 (Error)。
*   **AI汇报示例：** “前端API对接已完成，并处理了加载、成功和失败状态。下一步将进行端到端测试。”

**第五步：端到端集成测试与验证 (End-to-End Integration Testing & Verification)**

*   **行动：**
    1.  运行前后端应用，手动模拟真实用户操作。
    2.  **【测试要求】**：为当前功能编写至少一个核心场景的**端到端（E2E）自动化测试**（例如，使用 Cypress 或 Playwright）。
*   **验证与产出：**
    1.  通过手动的全链路验证。
    2.  可自动运行的**E2E测试脚本**。
*   **AI汇报示例：** “‘用户注册’功能已完成手动联调，并已添加E2E自动化测试脚本。此功能闭环完成。”

**第六步：代码完善与文档更新 (Refinement & Documentation)**

*   **行动：** 清理调试代码，根据需要添加注释，并（如果需要）更新API文档。
*   **产出物：** 干净、可维护的代码和最新的文档。

---

### **强制约束**

*   **禁止孤立开发：** 严禁连续实现超过一个后端API而不进行前端集成。
*   **强制状态汇报：** 在工作流的每一步完成后，AI都必须明确汇报当前完成的步骤和即将开始的下一步。
*   **错误即中断：** 如果在任何步骤（包括所有新增的测试环节）中发现问题或测试失败，必须立即停止并修复，直到当前功能闭环完全正确为止，才能继续新功能的开发。
